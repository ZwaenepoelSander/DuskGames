/*
Copyright (c) 2024 Dusk
All rights reserved.

This code is proprietary to Dusk AI Inc.
The code may be used solely for accessing the Service provided by Dusk AI Inc. following the Dusk Terms of Service ("Terms") accessible at dusk.gg/eula. You may not use this code for any use or purpose other than as expressly permitted by the Terms.
Restrictions set forth in the Terms include, but is not limited to, that you may not copy, adapt, modify, prepare derivative works based upon, distribute, license, sell, transfer, publicly display, publicly perform, transmit, stream, broadcast, attempt to discover any source code, reverse engineer, decompile, dissemble, or otherwise exploit the code as a whole or any portion of the code.
*/
type PersistedPlayers<PersistedData> = Record<PlayerId, PersistedData>;
type PersistedUsers<PersistedData> = Record<UserId, PersistedData>;
type GameStateWithPersisted<GameState, PersistedData> = GameState & {
    persisted: PersistedPlayers<PersistedData>;
};
type UntypedPersistedData = {};
type UntypedGameState = Record<string, any>;
type UntypedGameStateWithPersisted = GameStateWithPersisted<UntypedGameState, UntypedPersistedData>;
type UntypedInitLogicAction = (params?: any) => void;
type UntypedInitLogicActions = Record<string, UntypedInitLogicAction>;
type GameConfig = {
    landscape: boolean;
    minPlayers: number;
    maxPlayers: number;
    updatesPerSecond: number;
    eventCallbacks: {
        playerLeft: boolean;
        playerJoined: boolean;
    };
    update: boolean;
    persistPlayerData: boolean;
    reactive: boolean;
};
type SessionId = string;
type GameId = number;
type PlayerId = string;
type RandomSeed = number;
type Player = {
    playerId: PlayerId;
    displayName: string;
    avatarUrl: string;
};
type Players = Record<PlayerId, Player>;
type UserId = number;
type Spectator = {
    playerId: undefined;
};
type User = (Player | Spectator) & {
    userId: number;
    sdkProtocolVersion: number;
};
type Users = Record<UserId, User>;
type Environment = "runtime" | "devUI" | "test";

type LogFn = {
    (obj: object, msg: string): void;
    (msg: string): void;
};
type MsgLogger = {
    error: LogFn;
    warn: LogFn;
    info: LogFn;
};

type ServerErrorMessage = keyof typeof errorMap;
declare const errorMap: {
    GAME_OVER_INVALID_OPTIONS: {
        devUIMessage: string;
        consoleMessage: (data: any) => string;
        printExtraDataInDevUI: true;
    };
    STATE_SYNC_TOO_BIG: {
        devUIMessage: (data: any) => string;
    };
    SERVER_UPDATE_LOOP_FAILED: {
        devUIMessage: string;
        printExtraDataInDevUI: true;
    };
    ACTION_FAILED: {
        devUIMessage: (data: any) => string;
        printExtraDataInDevUI: true;
    };
    PLAYER_JOINED_FAILED: {
        devUIMessage: string;
        printExtraDataInDevUI: true;
    };
    PLAYER_LEFT_FAILED: {
        devUIMessage: string;
        printExtraDataInDevUI: true;
    };
    UPDATE_LOOP_BEHIND_GAME_TIME: {
        devUIUnexpected: true;
    };
    SERVER_UPDATE_LOOP_FASTER_THAN_GAME_TIME: {
        devUIUnexpected: true;
    };
    GET_GAME_STATE_FAILED: {
        devUIUnexpected: true;
    };
    SERVER_RECEIVED_MESSAGE_TOO_BIG: {
        devUIUnexpected: true;
    };
    SERVER_MESSAGE_TO_CLIENTS_TOO_BIG: {
        devUIUnexpected: true;
    };
    SERVER_FULL: {
        devUIUnexpected: true;
    };
    ON_PLAYER_JOINED_CALLBACK_MISSING: {
        devUIUnexpected: true;
    };
    ROOM_GAME_STATE_MISSING: {
        devUIUnexpected: true;
    };
    ACTION_PARAMS_SIZE_OVER_LIMIT: {
        devUIUnexpected: true;
    };
    SETUP_PERSISTED_KEY_NOT_ALLOWED: {
        devUIMessage: string;
    };
    PERSISTED_NOT_AN_OBJECT: {
        devUIMessage: string;
    };
    PERSISTED_KEY_MISSING: {
        devUIMessage: string;
    };
    PERSISTED_EXTRA_KEY_DETECTED: {
        devUIMessage: (data: any) => string;
    };
    PERSISTED_PLAYER_MISSING: {
        devUIMessage: (data: any) => string;
    };
    PERSISTED_PLAYER_NOT_AN_OBJECT: {
        devUIMessage: (data: any) => string;
    };
    PERSISTED_PLAYER_OVER_LIMIT: {
        devUIMessage: (data: any) => string;
    };
    SETUP_GAME_OVER_NOT_ALLOWED: {
        devUIMessage: string;
    };
    PERSISTED_STATE_NOT_ENABLED: {
        devUIUnexpected: true;
    };
    PERSISTED_STATE_USED_WITHOUT_FLAG: {
        devUIMessage: string;
    };
    SETUP_FAILED: {
        devUIMessage: string;
        printExtraDataInDevUI: true;
    };
    PERSIST_DATA_AFTER_ERROR_NOT_AVAILABLE: {
        devUIUnexpected: true;
    };
    GET_PERSISTED_STATE_FAILED: {
        devUIUnexpected: true;
    };
    GAME_END_PERSIST_USER_NOT_FOUND: {
        devUIUnexpected: true;
    };
    PLAYER_LEFT_NO_USERS_INCORRECT_PERSISTED_PLAYERS: {
        devUIUnexpected: true;
    };
};

type GameOverResult = "WON" | "LOST" | "TIE" | number;
type GameOverOptions = {
    delayPopUp?: boolean;
    minimizePopUp?: boolean;
} & ({
    players: {
        [playerId: PlayerId]: GameOverResult;
    };
    everyone?: never;
} | {
    players?: never;
    everyone: GameOverResult;
});
type GameOverGameEnded = {
    reason: "gameEnded";
    options: GameOverOptions;
};
type GameOverPlayerLeft = {
    reason: "playerLeft";
};
type GameOverMinPlayers = {
    reason: "minPlayers";
};
type GameOverError = {
    reason: "err";
    err?: {
        message: ServerErrorMessage;
        data?: object;
    };
};
type GameOverContext = (GameOverMinPlayers | GameOverPlayerLeft | GameOverGameEnded | GameOverError) & {
    players: Players;
};

type ContextWithGameState<Context, GameState, PersistedData> = Context & {
    game: PersistedData extends false ? GameState : GameStateWithPersisted<GameState, PersistedData>;
};
type EventContext = {
    allPlayerIds: PlayerId[];
};
type UpdateContext = {
    allPlayerIds: PlayerId[];
};
type ActionContext = {
    playerId: PlayerId;
    allPlayerIds: PlayerId[];
};
type InitLogicEvent<GameState, PersistedData> = (playerId: PlayerId, eventContext: ContextWithGameState<EventContext, GameState, PersistedData>) => void;
type InitLogicEvents<GameState, PersistedData> = {
    playerJoined?: InitLogicEvent<GameState, PersistedData>;
    playerLeft?: InitLogicEvent<GameState, PersistedData>;
};
type InitLogicUpdate<GameState, PersistedData> = (updateContext: ContextWithGameState<UpdateContext, GameState, PersistedData>) => void;
type InitLogicActions<GameState, GameActions extends UntypedInitLogicActions, PersistedData> = {
    [key in keyof GameActions]: (params: Parameters<GameActions[key]>[0], actionContext: ContextWithGameState<ActionContext, GameState, PersistedData>) => void;
};
type InitLogicParams<GameState, GameActions extends UntypedInitLogicActions, PersistedData> = {
    minPlayers: number;
    maxPlayers: number;
    landscape?: boolean;
    updatesPerSecond?: number;
    setup: (allPlayerIds: PlayerId[], context: PersistedData extends false ? undefined : {
        game: {
            persisted: PersistedPlayers<PersistedData>;
        };
    }) => GameState;
    actions: InitLogicActions<GameState, GameActions, PersistedData>;
    events?: InitLogicEvents<GameState, PersistedData>;
    update?: InitLogicUpdate<GameState, PersistedData>;
    inputDelay?: number;
    reactive?: boolean;
} & (PersistedData extends false ? {
    persistPlayerData?: false;
} : {
    persistPlayerData: true;
});
type SharedSdk<GameState, GameActions extends UntypedInitLogicActions, PersistedData> = {
    initLogic: (params: InitLogicParams<GameState, GameActions, PersistedData>) => void;
    invalidAction: () => Error;
    gameOver: (options?: GameOverOptions) => void;
    /** @deprecated, use gameTime() */
    gameTimeInSeconds: () => number;
    gameTime: () => number;
};

type LogicRunnerContext = {
    randomSeed: RandomSeed;
    msPerTick: number;
    logicTick: number;
};
type LogicRunnerResult<T> = {
    error: "ROOM_GAME_STATE_MISSING";
} | {
    data: T;
};
type LogicRunnerGameContext = {
    gameOver: GameOverContext | null;
};
type LogicRunnerReturnContext = {
    gameContext: LogicRunnerGameContext;
    stateHash?: number;
};
type LogicRunnerAction = (params: {
    roomId: number;
    logicContext: LogicRunnerContext;
    params: any;
    actionContext: ActionContext;
    calculateStateHash: boolean;
}) => LogicRunnerResult<LogicRunnerReturnContext | false>;
type LogicRunnerActions = Record<string, LogicRunnerAction>;
type PlayerJoinedEvent = (params: {
    roomId: number;
    logicContext: LogicRunnerContext;
    playerId: PlayerId;
    eventContext: EventContext;
    persistedPlayerState: UntypedPersistedData | null;
    calculateStateHash: boolean;
}) => LogicRunnerResult<LogicRunnerReturnContext>;
type PlayerLeftEvent = (params: {
    roomId: number;
    logicContext: LogicRunnerContext;
    playerId: PlayerId;
    eventContext: EventContext;
    calculateStateHash: boolean;
}) => LogicRunnerResult<LogicRunnerReturnContext & {
    persistedPlayers: PersistedPlayers<UntypedPersistedData> | null;
}>;
type LogicRunnerEvents = {
    playerJoined?: PlayerJoinedEvent;
    playerLeft?: PlayerLeftEvent;
};
type LogicRunnerUpdate = (params: {
    roomId: number;
    logicContext: LogicRunnerContext;
    updateContext: UpdateContext;
}) => LogicRunnerResult<LogicRunnerReturnContext>;
type LogicRunnerSetup = (params: {
    roomId: number;
    logicContext: LogicRunnerContext;
    playerIds: PlayerId[];
    calculateStateHash: boolean;
    persistedPlayers: PersistedPlayers<UntypedPersistedData> | null;
}) => {
    gameState: UntypedGameStateWithPersisted;
    stateHash?: number;
};
type SdkServer<GameState = UntypedGameState, GameActions extends UntypedInitLogicActions = UntypedInitLogicActions, PersistedData = false> = {
    gameConfig?: GameConfig;
    setup?: LogicRunnerSetup;
    actions?: LogicRunnerActions;
    events?: LogicRunnerEvents;
    update?: LogicRunnerUpdate;
    logicContext: LogicRunnerContext;
    gameOverContext: GameOverContext | null;
    rehydrate: (roomId: number, gameState: UntypedGameStateWithPersisted) => void;
    getActionNames: () => string[];
    getGameState: (roomId: number, calculateStateHash: boolean) => LogicRunnerResult<{
        gameState: UntypedGameStateWithPersisted;
        stateHash?: number;
    }>;
    cleanup: (roomId: number) => void;
    runAction: (action: string, ...args: Parameters<LogicRunnerAction>) => ReturnType<LogicRunnerAction>;
    runPlayerJoinedEvent: (...args: Parameters<PlayerJoinedEvent>) => ReturnType<PlayerJoinedEvent>;
    runPlayerLeftEvent: (...args: Parameters<PlayerLeftEvent>) => ReturnType<PlayerLeftEvent>;
    getPersistedData: (roomId: number, playerIds: PlayerId[]) => LogicRunnerResult<{
        persistedPlayers: PersistedPlayers<UntypedPersistedData>;
    }>;
} & SharedSdk<GameState, GameActions, PersistedData>;

type TimelineEntryStart = {
    type: "START";
    serverSeed: number;
    initialPlayers: Players;
    stateHash: number;
    persisted: PersistedPlayers<UntypedPersistedData> | null;
};
type TimelineEntryEnd = {
    type: "END";
    gameState: UntypedGameStateWithPersisted | string;
    stateHash: number;
    reason: GameOverContext["reason"] | "stop";
};
type TimelineEntryWithSuccess<T> = T & ({
    success: false;
} | {
    success: true;
    stateHash: number;
});
type TimelineEntryWithoutOrder = {
    logicTick: number;
} & (TimelineEntryStart | TimelineEntryEnd | TimelineEntryWithSuccess<{
    type: "ACTION";
    playerId: PlayerId;
    action: string;
    params: any;
    randomSeed: number;
}> | TimelineEntryWithSuccess<{
    type: "PLAYER_JOINED";
    player: Player;
    persisted: UntypedPersistedData | null;
}> | TimelineEntryWithSuccess<{
    type: "PLAYER_LEFT";
    playerId: PlayerId;
}>);
type TimelineEntry = TimelineEntryWithoutOrder & {
    order: number;
};

type SdkProtocolVersion = number;
type SdkMessageCodec = {
    encodeGameToServer(msg: GameToServer<UntypedInitLogicActions>, compress: boolean): string;
    encodeServerToGame(msg: ServerToGame<UntypedGameStateWithPersisted, UntypedInitLogicActions>, compress: boolean): string;
    decodeGameToServer(msg: string, logger: MsgLogger | null): GameToServer<UntypedInitLogicActions> | undefined;
    decodeServerToGame(msg: string, logger: MsgLogger | null): ServerToGame<UntypedGameStateWithPersisted, UntypedInitLogicActions> | undefined;
};

type Only<T, U> = {
    [P in keyof T]: T[P];
} & {
    [P in keyof U]?: never;
};
type Either<T, U> = Only<T, U> | Only<U, T>;

type PlayersRandomState = Record<PlayerId, {
    seed: RandomSeed;
    actionCount: number;
}>;
type GameContext = {
    readonly gameOver: GameOverContext | null;
    orderNumber: number;
    sessionId: SessionId;
    gameId: GameId;
};
type ServerSerializationData<GameStateWithPersisted> = {
    game: GameStateWithPersisted;
} & ServerState;
type ServerState = {
    context: GameContext;
    random: PlayersRandomState;
    gameTime: number;
    updateCount: number;
};
type UpdateLoopContext = {
    logicTick: number;
};
type RunGameLogic = {
    getConfig: () => GameConfig;
    getActionNames: (msgLogger: MsgLogger, ...args: Parameters<SdkServer["getActionNames"]>) => Promise<ReturnType<SdkServer["getActionNames"]>>;
    getGameState: (msgLogger: MsgLogger, ...args: Parameters<SdkServer["getGameState"]>) => Promise<ReturnType<SdkServer["getGameState"]>>;
    getPersistedData: (msgLogger: MsgLogger, ...args: Parameters<SdkServer["getPersistedData"]>) => Promise<ReturnType<SdkServer["getPersistedData"]>>;
    runSetup: (msgLogger: MsgLogger, ...args: Parameters<LogicRunnerSetup>) => Promise<ReturnType<LogicRunnerSetup>>;
    runPlayerJoinedEvent: (msgLogger: MsgLogger, ...args: Parameters<SdkServer["runPlayerJoinedEvent"]>) => Promise<ReturnType<SdkServer["runPlayerJoinedEvent"]>>;
    runPlayerLeftEvent: (msgLogger: MsgLogger, ...args: Parameters<SdkServer["runPlayerLeftEvent"]>) => Promise<ReturnType<SdkServer["runPlayerLeftEvent"]>>;
    runAction: (msgLogger: MsgLogger, ...args: Parameters<SdkServer["runAction"]>) => Promise<ReturnType<SdkServer["runAction"]>>;
    runUpdate: (msgLogger: MsgLogger, ...args: Parameters<LogicRunnerUpdate>) => Promise<ReturnType<LogicRunnerUpdate>>;
    rehydrate: (msgLogger: MsgLogger, ...args: Parameters<SdkServer["rehydrate"]>) => Promise<ReturnType<SdkServer["rehydrate"]>>;
    cleanup: (msgLogger: MsgLogger, ...args: Parameters<SdkServer["cleanup"]>) => Promise<ReturnType<SdkServer["cleanup"]>>;
};
type GameServer<GameState, PersistedData> = {
    onMsg: (msgLogger: MsgLogger, userId: UserId, msg: string, info: {
        serverPreprocessingDurationInMs: number;
    }) => Promise<void>;
    onPlayerJoined: (msgLogger: MsgLogger, playerId: PlayerId, persistedUserData: PersistedData) => Promise<void>;
    onPlayerLeft: (msgLogger: MsgLogger, playerId: PlayerId) => Promise<PersistedData | null>;
    getDataForSerialization: (msgLogger: MsgLogger) => Promise<ServerSerializationData<GameStateWithPersisted<GameState, PersistedData>>>;
    getConfig: () => GameConfig;
    getSessionId: () => SessionId;
    getGameId: () => GameId;
    getPersistedUsers: (msgLogger: MsgLogger, userIds?: UserId[]) => Promise<PersistedUsers<UntypedPersistedData>>;
    isGameOver: () => boolean;
    onUpdateLoop: (msgLogger: MsgLogger, updateLoopContext: UpdateLoopContext) => Promise<void>;
    cleanup: (msgLogger: MsgLogger) => Promise<PersistedUsers<UntypedPersistedData> | null>;
    getCodec: () => SdkMessageCodec;
};
type NetworkServer = {
    getUsers: () => Users;
    broadcastMsg: (msgLogger: MsgLogger, msg: string) => void;
    sendMsg: (msgLogger: MsgLogger, userId: UserId, msg: string) => void;
    queueUpdateLoop: (updateLoopContext: UpdateLoopContext) => void;
    onGameOver: (msgLogger: MsgLogger, reason: GameOverContext["reason"], persistedUsers: PersistedUsers<UntypedPersistedData> | null) => void;
    onTimelineEntry?: (msgLogger: MsgLogger, timelineEntry: TimelineEntry) => void;
    getSeedForPlayerId?: (playerId: PlayerId) => number;
};
type CreateGameServerProps = {
    initialMsgLogger: MsgLogger;
    network: NetworkServer;
    logic: RunGameLogic;
    flags: {
        logServerClientGameTime?: boolean;
        logNetworkMsg?: boolean;
        logWrongTick?: boolean;
        logNetworkMsgSize?: boolean;
        sendInitialStateSync?: boolean;
        sendStateHash?: boolean;
        isPersistFeatureEnabled: boolean;
    };
    params: {
        sessionId: string | null;
        roomId: number;
        gameId: GameId;
        serverSeed: RandomSeed;
    } & Either<{
        persistedUsers: PersistedUsers<UntypedPersistedData>;
    }, {
        initialServerData: ServerSerializationData<UntypedGameStateWithPersisted>;
    }>;
    config: {
        logicTimeoutDuration?: number | false;
        allowedGameTimeDelay?: number;
        gameTimeUpdateEveryXTicks?: number;
        environment: Environment;
        sdkProtocolVersion: SdkProtocolVersion;
    };
};

type ServerToGameBase = {
    orderNumber: number;
    serverGameTime: number;
    logicTick: number;
};
type OnChangeMsgAction<GameActions extends UntypedInitLogicActions> = {
    [Key in keyof GameActions]: {
        action: Key;
        playerId: PlayerId;
        params: Parameters<GameActions[Key]>[0];
    };
}[keyof GameActions];
type ActionBase = {
    uuid: string;
    actionCount: number;
    sessionId: SessionId;
    randomSeed: RandomSeed;
    measureLatencyStart: number;
};
type GameToServerAction<GameActions extends UntypedInitLogicActions> = OnChangeMsgAction<GameActions> & ActionBase & {
    clientGameTime: number;
    expectedLogicTick: number;
};
type ServerToGameAction<GameActions extends UntypedInitLogicActions> = ServerToGameBase & OnChangeMsgAction<GameActions> & ActionBase & {
    stateHash: number | undefined;
};
type OnChangeStateSyncEvent = {
    event: "stateSync";
};
type ServerToGameGameTimeUpdate = ServerToGameBase & {
    event: "gameTimeUpdate";
    params: {
        gameContext: GameContext;
    };
};
type ServerToGameLatencyEstimate = {
    event: "latencyEstimate";
    measureLatencyStart: number;
    serverGameTime: number;
};
type ServerToGameStopGameEvent = {
    event: "debugStopGame";
};
type ServerToGameStateSyncEvent<GameStateWithPersisted> = ServerToGameBase & OnChangeStateSyncEvent & {
    params: {
        game: GameStateWithPersisted;
        gameContext: GameContext;
        players: Players;
        pastPlayerIds: PlayerId[];
        yourPlayerSeed: RandomSeed | undefined;
        yourPlayerActionCount: number | undefined;
        yourPlayerId: PlayerId | undefined;
        serverSeed: RandomSeed;
        triggeredByUpdateLoop: boolean;
        measureLatencyStart?: number;
        latencyRttEstimate?: number;
    };
    dictionary?: string[];
};
type OnChangePlayerJoinedEvent = {
    event: "playerJoined";
    params: {
        playerId: PlayerId;
    };
};
type ServerToGamePlayerJoinedEvent = ServerToGameBase & OnChangePlayerJoinedEvent & {
    params: {
        playerId: PlayerId;
        gameContext: GameContext;
        players: Players;
        randomSeed: RandomSeed;
        stateHash: number | undefined;
        persistedPlayerState?: UntypedPersistedData;
    };
};
type OnChangePlayerLeftEvent = {
    event: "playerLeft";
    params: {
        playerId: PlayerId;
    };
};
type ServerToGamePlayerLeftEvent = ServerToGameBase & OnChangePlayerLeftEvent & {
    params: {
        playerId: PlayerId;
        gameContext: GameContext;
        players: Players;
        randomSeed: RandomSeed;
        stateHash: number | undefined;
    };
};
type ServerToGameOnChangeTriggeringEvent<GameStateWithPersisted> = ServerToGameStateSyncEvent<GameStateWithPersisted> | ServerToGamePlayerJoinedEvent | ServerToGamePlayerLeftEvent;
type ServerToGameEvent<GameStateWithPersisted> = ServerToGameOnChangeTriggeringEvent<GameStateWithPersisted> | ServerToGameGameTimeUpdate | ServerToGameLatencyEstimate | ServerToGameStopGameEvent;
type ServerToGame<GameStateWithPersisted, GameActions extends UntypedInitLogicActions> = ServerToGameAction<GameActions> | ServerToGameEvent<GameStateWithPersisted>;
type GameToServer<GameActions extends UntypedInitLogicActions> = GameToServerAction<GameActions> | GameToServerStateSyncRequest | {
    type: "MEASURE_LATENCY";
    measureLatencyStart: number;
} | {
    type: "DEBUG_TIMELINE";
    data: any;
};
type GameToServerStateSyncRequest = {
    type: "REQUEST_STATE_SYNC";
    measureLatencyStart: number;
    gameId: number | null;
};

declare function generateId(length?: number): string;

declare function isNewUserSpectator(users: Users, gameConfig: GameConfig, isGameOver: boolean): boolean;
declare function canSwitchSpectatorToPlayer(users: Users, gameConfig: GameConfig): boolean;

declare function createSdkForLogicRunner(environment: Environment): SdkServer;

declare function createGameServer({ initialMsgLogger, params: { gameId, roomId, sessionId, initialServerData, serverSeed, persistedUsers, }, flags: { sendStateHash: sendStateHashFlag, logWrongTick, logNetworkMsg, logNetworkMsgSize, sendInitialStateSync, isPersistFeatureEnabled, }, config: { logicTimeoutDuration, allowedGameTimeDelay, gameTimeUpdateEveryXTicks, environment, sdkProtocolVersion, }, network, logic, }: CreateGameServerProps): Promise<GameServer<UntypedGameState, UntypedPersistedData>>;

export { CreateGameServerProps, GameConfig, GameId, GameOverContext, GameServer, MsgLogger, PersistedUsers, Player, RunGameLogic, SdkServer, ServerSerializationData, SessionId, UntypedGameState, UntypedGameStateWithPersisted, UntypedPersistedData, User, canSwitchSpectatorToPlayer, createGameServer, createSdkForLogicRunner, generateId, isNewUserSpectator };
